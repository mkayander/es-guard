# ES-Guard Project Development Rules

## Project Overview

ES-Guard is a TypeScript-based tool that ensures JavaScript code compatibility with target environments using ESLint. It provides both CLI and programmatic APIs for checking ES version compatibility and browser support.

## Technology Stack

- **Language**: TypeScript (strict mode enabled)
- **Runtime**: Node.js
- **Package Manager**: PNPM (required, not NPM)
- **Testing**: Vitest with coverage thresholds
- **Linting**: ESLint with TypeScript rules
- **Formatting**: Prettier
- **Build**: TypeScript compiler (tsc)
- **Module System**: ES Modules (ESM)

## Project Structure

```
src/
├── lib/           # Core library modules
├── cli.ts         # Command-line interface
└── index.ts       # Main entry point and exports
```

## Development Setup

1. **Install dependencies**: `pnpm install` (never use npm)
2. **Build project**: `pnpm run build`
3. **Development mode**: `pnpm run dev` (watch mode)
4. **Clean build**: `pnpm run clean`

## Key Development Commands

- `pnpm run build` - Build the project
- `pnpm run dev` - Watch mode development
- `pnpm run test` - Run tests with coverage
- `pnpm run test:dev` - Run tests in watch mode
- `pnpm run lint` - Run ESLint
- `pnpm run lint:check` - Check linting without warnings
- `pnpm run format` - Format code with Prettier
- `pnpm run format:check` - Check formatting
- `pnpm run coverage` - Generate coverage report

## Code Quality Standards

### TypeScript Rules

- **NEVER** use `as any`, `as unknown`, `!` to bypass TypeScript errors
- Always analyze and fix root causes of type errors
- Use strict TypeScript configuration
- Export types from `src/lib/types.ts`
- Use consistent type imports: `import type { ... }`

### ESLint Configuration

- Strict TypeScript rules enabled
- No unused variables allowed
- No explicit `any` types
- Consistent type imports required
- Function return types inferred (not required)

### Testing Requirements

- Use Vitest for testing
- Maintain 80% coverage globally, 90% for lib modules
- Test files: `src/**/*.{test,spec}.ts`
- Never write tests that solely check constants or static values
- Object structure checks handled by TypeScript

### Running Tests

**All Tests:**

```bash
pnpm run test              # Build and run all tests
pnpm run test:dev          # Build and run tests in watch mode
pnpm run test:watch        # Run tests in watch mode (no build)
pnpm run test:only         # Run tests without building (requires previous build)
```

**Specific Tests:**

```bash
# Run a specific test file
pnpm run build && pnpm run test:only src/path/to/test.ts

# Run a specific test by name pattern
pnpm run build && pnpm run test:only -t "test name pattern"

# Run tests matching a pattern (no build needed if already built)
pnpm run test:only -t "pattern"
```

**Coverage:**

```bash
pnpm run coverage          # Generate coverage report
pnpm run coverage:check    # Check coverage with verbose output
```

### Writing Tests

**Test File Structure:**

- Test files use `.test.ts` or `.spec.ts` extension
- Place unit tests next to source files: `src/lib/module.test.ts`
- Place integration tests in `src/__tests__/` directory
- Use Vitest's `describe`, `test`/`it`, `expect` from `vitest`

**Test Patterns:**

1. **Unit Tests (with mocks):**

```typescript
import { vi } from "vitest";

// Mock external dependencies
const mockLintFiles = vi.fn();
vi.mock("eslint", () => ({
  ESLint: class {
    lintFiles = mockLintFiles;
  },
}));

test("should handle specific case", async () => {
  mockLintFiles.mockResolvedValueOnce([...]);
  // Test implementation
});
```

2. **Integration Tests (real ESLint):**

```typescript
// No mocks - uses real ESLint
import { checkCompatibility } from "../lib/checkCompatiblity.js";

test("should detect browser compatibility issues", async () => {
  const testFile = path.join(testDir, "test.js");
  fs.writeFileSync(testFile, "fetch('/api');");

  const result = await checkCompatibility({
    dir: testDir,
    target: "2015",
    browsers: "ie 11",
  });

  expect(result.warnings.length).toBeGreaterThan(0);
});
```

3. **Console Output Tests:**

```typescript
import { vi } from "vitest";

import { runESGuard } from "../main.js";

test("should output compat/compat warnings to console", async () => {
  const consoleOutput: string[] = [];
  const consoleWarnSpy = vi.spyOn(console, "warn").mockImplementation((...args) => {
    consoleOutput.push(args.map(String).join(" "));
  });

  try {
    await runESGuard({ directory: testDir, target: "2015", browsers: "ie 11" });
    const allOutput = consoleOutput.join(" ");
    expect(allOutput).toContain("compat/compat");
  } finally {
    consoleWarnSpy.mockRestore();
  }
});
```

**Test Best Practices:**

- Use `beforeEach`/`afterEach` for setup/cleanup
- Create temporary directories for file-based tests
- Clean up test files/directories in `afterEach`
- Use descriptive test names that explain what is being tested
- Test both success and error cases
- For browser API compatibility tests, use actual browser APIs (fetch, IntersectionObserver, etc.), not syntax features

## Architecture Guidelines

### Module Organization

- Core functionality in `src/lib/`
- CLI interface in `src/cli.ts`
- Main exports in `src/index.ts`
- Avoid import cycles - move shared code to separate modules
- Export existing code instead of duplicating

### API Design

- Provide both CLI and programmatic interfaces
- Use async/await for compatibility checks
- Implement proper error handling and validation
- Support auto-detection of project configuration
- Maintain backward compatibility

### File Naming

- Use kebab-case for files: `checkCompatiblity.ts`
- Test files: `*.test.ts` or `*.spec.ts`
- Export main functions from index files

## Key Modules

### Core Modules (`src/lib/`)

- `checkCompatiblity.ts` - Main compatibility checking logic
  - Handles source map resolution for webpack:// and turbopack:// protocols
  - Filters messages to only include compat/compat and parsing errors (ruleId: null)
  - Formats violation messages with source map information
- `detectTarget.ts` - Project configuration detection
- `getBrowserTargets.ts` - Browser target utilities
- `validateConfig.ts` - Configuration validation
- `projectType.ts` - Project type detection
- `globalState.ts` - Global state management
- `types.ts` - TypeScript type definitions

### Important Implementation Details

**Message Filtering:**

- Only include messages where `ruleId === "compat/compat"` or `ruleId === null` (parsing errors)
- Filter out messages containing "has no effect because you have 'noInlineConfig'"
- This ensures only compatibility-related messages are shown

**Source Map Chain Following:**

- Recursively follows source map chains to find original source
- Stops when reaching build tool protocol URLs (webpack://, turbopack://)
- Handles multiple layers of source maps (e.g., TypeScript → JavaScript → Minified)

**Path Resolution Strategy:**

- For turbopack: Extract path after `[project]/` prefix
- For webpack: Extract path after protocol prefix
- Try baseDir first (most common), then walk up from compiled file
- Only add common prefixes (src/, app/, etc.) if path doesn't already start with them

### CLI Interface

- `src/cli.ts` - Command-line interface using Commander.js
- Supports ES version targets (year/numeric format)
- Browser target specification
- Directory scanning capabilities

## Development Workflow

### Adding New Features

1. Create feature branch
2. Implement in appropriate module under `src/lib/`
3. Add comprehensive tests
4. Update exports in `src/index.ts`
5. Update documentation and examples
6. Ensure all tests pass and coverage meets thresholds

### Testing Strategy

- Unit tests for all library functions
- Integration tests for CLI functionality
- Test both success and error cases
- Mock external dependencies appropriately
- Use descriptive test names

### Code Review Checklist

- [ ] TypeScript strict mode compliance
- [ ] No type assertions or bypasses
- [ ] Proper error handling
- [ ] Test coverage maintained
- [ ] ESLint rules followed
- [ ] Prettier formatting applied
- [ ] No import cycles
- [ ] No code duplication
- [ ] Source map paths correctly resolved
- [ ] Console output tests verify actual output
- [ ] Integration tests use real ESLint (not mocks)

## Dependencies

### Production Dependencies

- `@babel/code-frame` - Code frame formatting
- `chalk` - Terminal colorization
- `commander` - CLI argument parsing
- `eslint` - Core linting engine
- `eslint-plugin-compat` - Browser compatibility checking
- `source-map` - Source map parsing

### Development Dependencies

- `@eslint/js` - ESLint JavaScript rules
- `@typescript-eslint/*` - TypeScript ESLint support
- `vitest` - Testing framework
- `@vitest/coverage-v8` - Coverage reporting
- `prettier` - Code formatting
- `semantic-release` - Automated releases

## Performance Considerations

- Efficient directory scanning
- Lazy loading of ESLint configurations
- Minimal memory footprint
- Fast compatibility checking
- Optimized for CI/CD environments

## Error Handling

- Comprehensive error messages
- Source map integration for accurate line numbers
- Graceful fallbacks for missing configurations
- Detailed validation of user inputs
- Proper error propagation through async operations

## Source Map Handling

### Build Tool Protocols

ES-Guard supports source maps from various build tools:

- **Webpack**: `webpack:///./path/to/file.ts`
- **Turbopack**: `turbopack:///[project]/path/to/file.ts`

### Source Map Resolution

The `resolveFilePath` function handles path resolution with this priority:

1. **Direct path from baseDir** (project root) - fastest and most common
2. **Walk up from compiled file** - for Next.js `.next/static/chunks/` output
3. **Common prefixes** - only if path doesn't already start with `src/`, `app/`, etc.

### Key Functions

- `checkIsBuildToolProtocol(filePath)` - Checks if path is webpack:// or turbopack://
- `extractPathFromBuildToolProtocol(originalFile)` - Extracts file path from protocol URL
- `resolveFilePath(extractedPath, baseDir, compiledFilePath?)` - Resolves to actual file system path
- `getOriginalSourceMap(jsFile)` - Recursively follows source map chains

### Display Format

- Always show original import path (e.g., `turbopack:///[project]/src/file.ts`) in output
- Do NOT show resolved file:// URI in parentheses (removed for cleaner output)
- Use `[src]` indicator when source file is readable, `[map]` when only source map available

## Integration Points

- GitHub Actions workflows
- Build tool integration (Webpack, Vite, Rollup)
- CI/CD pipelines
- Editor plugins
- Custom build scripts
